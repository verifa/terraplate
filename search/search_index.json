{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Terraplate is a thin wrapper around Terraform to keep things DRY and improve the developer experience. How it works \u00b6 Terraplate traverses up and down from the working directory detecting Terraplate files (AKA \"Terrafiles\"), treating the Terrafiles without child Terrafiles as Root Modules (i.e. if a Terrafile does not have any children, it's considered a Root Module where Terraform should be run). Terraplate builds Terraform files based on your provided templates (using Go Templates). Define your Terraform snippets once, and reuse them with Go Templates to substitute the values based on the different root modules. The built files are completely normal Terraform files that should be version controlled and can be applied either via the terraform CLI or using the terraplate CLI. This way you can focus on writing your Terraform code that creates resources, and let Terraplate handle the boilerplate (like backend, providers, configuration, etc) based on your provided templates. The goal of Terraplate is to not do any magic: just plain (but DRY) Terraform, which means you can bring your own tools for static analysis, security, policies, testing and deployment. The terraplate CLI allows you to run Terraform across all your Root Modules and provide a summary of plans. Motivation \u00b6 As you scale your Terraform usage you will start to split your resources out across multiple Terraform Root Modules . Each Root Module must define it's own backend (state storage), providers and versions, and this can lead to a lot of copy+paste. Not very DRY. Keeping things DRY \u00b6 There are existing techniques to keep things DRY, two notable mentions: Terraform Workspaces solve the issue when you have multiple environments (e.g. prod & dev) for the same infrastructure, not multiple completely unrelated Root Modules. Nonetheless, it helps reduce the amount of copied code. Check the FAQ on the subject . Terragrunt : Terragrunt inspired Terraplate and therefore it is no surprise that Terraplate has a similar feel. However, there are differences that we feel warranted the development of another tool. Check the FAQ on the subject . Multiple Root Modules \u00b6 There are existing approaches to running Terraform (e.g. init, plan, apply) over multiple Root Modules (directories): Terragrunt : This is one of Terragrunt's core features, but only works if you use Terragrunt Terraform Cloud : Terraform cloud allows you to create Workspaces for each Root Module SpaceLift : SpaceLift is similar to Terraform Cloud but calls it \"Stacks\" instead of Workspaces. Custom: write a bash script or something and run it in your CI :) Terraplate's templating is compatible with all the approaches above (in fact Terraplate can template your Terragrunt files! But let's not go there...). That means you can use Terraplate for just templating and keeping things DRY but it also comes with a thin wrapper for invoking Terraform (similar to Terragrunt). Drift detection \u00b6 Terraplate can be run on a regular basis and detect drift in your infrastructure and create notifications. Currenly only Slack will be supported, but we welcome ideas/suggestions for more! Who is it for \u00b6 Terraform users with multiple Root Modules \u00b6 Once you start to scale your Terraform usage you will not want to put all of your code into a single root module (i.e. a single state). The two main benefits Terraplate brings is: Keeping your code DRY and more maintainable Improve developer productivity by spending less time writing boilerplate and running Terraform across all your Root Modules Dev mode \u00b6 Terraplate has a \"dev\" mode which launches a Terminal UI, for browsing Root modules and running commands: Terraform users who want to make Workspaces more DRY or avoid them \u00b6 If you don't find workspaces completely solves the issue of DRY infra, or they are not right for you, Terraplate is worth considering. Terraplate is not a replacement, but something that can solve the same problem and be used together with workspaces. Check the FAQ on the subject . Overcoming limitations of Terraform's dynamic behavior \u00b6 An example of a limitation is the ability to do for_each for providers (or even dynamically reference providers to pass to modules using a for_each ). With Terraplate, you can build the .tf Terraform file that creates the providers and invokes the modules and overcome this. It's not the cleanest, but we've found it much friendlier than the numerous workarounds we have to do to achieve the same thing with vanilla Terraform.","title":"Introduction"},{"location":"#how-it-works","text":"Terraplate traverses up and down from the working directory detecting Terraplate files (AKA \"Terrafiles\"), treating the Terrafiles without child Terrafiles as Root Modules (i.e. if a Terrafile does not have any children, it's considered a Root Module where Terraform should be run). Terraplate builds Terraform files based on your provided templates (using Go Templates). Define your Terraform snippets once, and reuse them with Go Templates to substitute the values based on the different root modules. The built files are completely normal Terraform files that should be version controlled and can be applied either via the terraform CLI or using the terraplate CLI. This way you can focus on writing your Terraform code that creates resources, and let Terraplate handle the boilerplate (like backend, providers, configuration, etc) based on your provided templates. The goal of Terraplate is to not do any magic: just plain (but DRY) Terraform, which means you can bring your own tools for static analysis, security, policies, testing and deployment. The terraplate CLI allows you to run Terraform across all your Root Modules and provide a summary of plans.","title":"How it works"},{"location":"#motivation","text":"As you scale your Terraform usage you will start to split your resources out across multiple Terraform Root Modules . Each Root Module must define it's own backend (state storage), providers and versions, and this can lead to a lot of copy+paste. Not very DRY.","title":"Motivation"},{"location":"#keeping-things-dry","text":"There are existing techniques to keep things DRY, two notable mentions: Terraform Workspaces solve the issue when you have multiple environments (e.g. prod & dev) for the same infrastructure, not multiple completely unrelated Root Modules. Nonetheless, it helps reduce the amount of copied code. Check the FAQ on the subject . Terragrunt : Terragrunt inspired Terraplate and therefore it is no surprise that Terraplate has a similar feel. However, there are differences that we feel warranted the development of another tool. Check the FAQ on the subject .","title":"Keeping things DRY"},{"location":"#multiple-root-modules","text":"There are existing approaches to running Terraform (e.g. init, plan, apply) over multiple Root Modules (directories): Terragrunt : This is one of Terragrunt's core features, but only works if you use Terragrunt Terraform Cloud : Terraform cloud allows you to create Workspaces for each Root Module SpaceLift : SpaceLift is similar to Terraform Cloud but calls it \"Stacks\" instead of Workspaces. Custom: write a bash script or something and run it in your CI :) Terraplate's templating is compatible with all the approaches above (in fact Terraplate can template your Terragrunt files! But let's not go there...). That means you can use Terraplate for just templating and keeping things DRY but it also comes with a thin wrapper for invoking Terraform (similar to Terragrunt).","title":"Multiple Root Modules"},{"location":"#drift-detection","text":"Terraplate can be run on a regular basis and detect drift in your infrastructure and create notifications. Currenly only Slack will be supported, but we welcome ideas/suggestions for more!","title":"Drift detection"},{"location":"#who-is-it-for","text":"","title":"Who is it for"},{"location":"#terraform-users-with-multiple-root-modules","text":"Once you start to scale your Terraform usage you will not want to put all of your code into a single root module (i.e. a single state). The two main benefits Terraplate brings is: Keeping your code DRY and more maintainable Improve developer productivity by spending less time writing boilerplate and running Terraform across all your Root Modules","title":"Terraform users with multiple Root Modules"},{"location":"#dev-mode","text":"Terraplate has a \"dev\" mode which launches a Terminal UI, for browsing Root modules and running commands:","title":"Dev mode"},{"location":"#terraform-users-who-want-to-make-workspaces-more-dry-or-avoid-them","text":"If you don't find workspaces completely solves the issue of DRY infra, or they are not right for you, Terraplate is worth considering. Terraplate is not a replacement, but something that can solve the same problem and be used together with workspaces. Check the FAQ on the subject .","title":"Terraform users who want to make Workspaces more DRY or avoid them"},{"location":"#overcoming-limitations-of-terraforms-dynamic-behavior","text":"An example of a limitation is the ability to do for_each for providers (or even dynamically reference providers to pass to modules using a for_each ). With Terraplate, you can build the .tf Terraform file that creates the providers and invokes the modules and overcome this. It's not the cleanest, but we've found it much friendlier than the numerous workarounds we have to do to achieve the same thing with vanilla Terraform.","title":"Overcoming limitations of Terraform's dynamic behavior"},{"location":"examples/","text":"Check out the Terraplate examples in our GitHub repository.","title":"Examples"},{"location":"installation/","text":"Terraplate is written in Go and uses the awesome GoReleaser project to release and publish. Docker \u00b6 docker pull verifa/terraplate Brew \u00b6 brew install verifa/tap/terraplate Standalone \u00b6 Check the GitHub Releases: https://github.com/verifa/terraplate/releases","title":"Installation"},{"location":"installation/#docker","text":"docker pull verifa/terraplate","title":"Docker"},{"location":"installation/#brew","text":"brew install verifa/tap/terraplate","title":"Brew"},{"location":"installation/#standalone","text":"Check the GitHub Releases: https://github.com/verifa/terraplate/releases","title":"Standalone"},{"location":"project-status/","text":"Terraplate is stable and being used in production. There should be no breaking changes unless there is a new major version. Terraplate does not have a cache, cleanup functionality or overwrite protection. It's quite dumb, by design, so please be careful that you do not overwrite existing files.","title":"Project Status"},{"location":"quick-start/","text":"Let's get you using Terraplate ASAP! Installation \u00b6 See installation instructions Example \u00b6 Clone Terraplate \u00b6 The Terraplate repository comes with some examples. Let's start with the simple one. git clone https://github.com/verifa/terraplate.git cd terraplate/examples/simple Run Terraplate \u00b6 # Parse the Terrafiles and print some details terraplate parse # Build the templates terraplate build # Plan the root modules terraplate plan # Apply the root modules terraplate apply Tutorials \u00b6 Check the tutorials for learning about how to setup a project using Terraplate Reference \u00b6 The complete terrafile reference tells you everything you can put into a Terrafile.","title":"Quick Start"},{"location":"quick-start/#installation","text":"See installation instructions","title":"Installation"},{"location":"quick-start/#example","text":"","title":"Example"},{"location":"quick-start/#clone-terraplate","text":"The Terraplate repository comes with some examples. Let's start with the simple one. git clone https://github.com/verifa/terraplate.git cd terraplate/examples/simple","title":"Clone Terraplate"},{"location":"quick-start/#run-terraplate","text":"# Parse the Terrafiles and print some details terraplate parse # Build the templates terraplate build # Plan the root modules terraplate plan # Apply the root modules terraplate apply","title":"Run Terraplate"},{"location":"quick-start/#tutorials","text":"Check the tutorials for learning about how to setup a project using Terraplate","title":"Tutorials"},{"location":"quick-start/#reference","text":"The complete terrafile reference tells you everything you can put into a Terrafile.","title":"Reference"},{"location":"commands/terraplate/","text":"terraplate \u00b6 DRY Terraform using Go Templates Synopsis \u00b6 DRY Terraform using Go Templates. Terraplate keeps your Terraform DRY. Create templates that get built using Go Templates to avoid repeating common Terraform configurations like providers and backend. Options \u00b6 -C, --chdir string Switch to a different working directory before executing the given subcommand. (default \".\") -h, --help help for terraplate SEE ALSO \u00b6 terraplate apply - Runs terraform apply on all subdirectories terraplate build - Build Terraform files based your Terrafiles terraplate dev - Enters dev mode which launches a Terminal UI for Terraplate terraplate drift - Detect drift in your infrastructure (experimental feature) terraplate init - Runs terraform init on all subdirectories terraplate parse - Parse the terraplate files and print a summary terraplate plan - Runs terraform plan on all subdirectories terraplate show - Runs terraform show on all subdirectories terraplate version - Show the Terraplate version","title":"terraplate"},{"location":"commands/terraplate/#terraplate","text":"DRY Terraform using Go Templates","title":"terraplate"},{"location":"commands/terraplate/#synopsis","text":"DRY Terraform using Go Templates. Terraplate keeps your Terraform DRY. Create templates that get built using Go Templates to avoid repeating common Terraform configurations like providers and backend.","title":"Synopsis"},{"location":"commands/terraplate/#options","text":"-C, --chdir string Switch to a different working directory before executing the given subcommand. (default \".\") -h, --help help for terraplate","title":"Options"},{"location":"commands/terraplate/#see-also","text":"terraplate apply - Runs terraform apply on all subdirectories terraplate build - Build Terraform files based your Terrafiles terraplate dev - Enters dev mode which launches a Terminal UI for Terraplate terraplate drift - Detect drift in your infrastructure (experimental feature) terraplate init - Runs terraform init on all subdirectories terraplate parse - Parse the terraplate files and print a summary terraplate plan - Runs terraform plan on all subdirectories terraplate show - Runs terraform show on all subdirectories terraplate version - Show the Terraplate version","title":"SEE ALSO"},{"location":"commands/terraplate_apply/","text":"terraplate apply \u00b6 Runs terraform apply on all subdirectories Synopsis \u00b6 Runs terraform apply on all subdirectories. terraplate apply [flags] Options \u00b6 -h, --help help for apply -j, --jobs int Number of concurrent terraform jobs to run at one time (default 4) Options inherited from parent commands \u00b6 -C, --chdir string Switch to a different working directory before executing the given subcommand. (default \".\") SEE ALSO \u00b6 terraplate - DRY Terraform using Go Templates","title":"terraplate apply"},{"location":"commands/terraplate_apply/#terraplate-apply","text":"Runs terraform apply on all subdirectories","title":"terraplate apply"},{"location":"commands/terraplate_apply/#synopsis","text":"Runs terraform apply on all subdirectories. terraplate apply [flags]","title":"Synopsis"},{"location":"commands/terraplate_apply/#options","text":"-h, --help help for apply -j, --jobs int Number of concurrent terraform jobs to run at one time (default 4)","title":"Options"},{"location":"commands/terraplate_apply/#options-inherited-from-parent-commands","text":"-C, --chdir string Switch to a different working directory before executing the given subcommand. (default \".\")","title":"Options inherited from parent commands"},{"location":"commands/terraplate_apply/#see-also","text":"terraplate - DRY Terraform using Go Templates","title":"SEE ALSO"},{"location":"commands/terraplate_build/","text":"terraplate build \u00b6 Build Terraform files based your Terrafiles Synopsis \u00b6 Build (or generate) the Terraform files. For each Terrafile that is detected, build the Terraform files using the templates and configurations detected. terraplate build [flags] Options \u00b6 -h, --help help for build --validate Validate (requires init) each root module after build Options inherited from parent commands \u00b6 -C, --chdir string Switch to a different working directory before executing the given subcommand. (default \".\") SEE ALSO \u00b6 terraplate - DRY Terraform using Go Templates","title":"terraplate build"},{"location":"commands/terraplate_build/#terraplate-build","text":"Build Terraform files based your Terrafiles","title":"terraplate build"},{"location":"commands/terraplate_build/#synopsis","text":"Build (or generate) the Terraform files. For each Terrafile that is detected, build the Terraform files using the templates and configurations detected. terraplate build [flags]","title":"Synopsis"},{"location":"commands/terraplate_build/#options","text":"-h, --help help for build --validate Validate (requires init) each root module after build","title":"Options"},{"location":"commands/terraplate_build/#options-inherited-from-parent-commands","text":"-C, --chdir string Switch to a different working directory before executing the given subcommand. (default \".\")","title":"Options inherited from parent commands"},{"location":"commands/terraplate_build/#see-also","text":"terraplate - DRY Terraform using Go Templates","title":"SEE ALSO"},{"location":"commands/terraplate_dev/","text":"terraplate dev \u00b6 Enters dev mode which launches a Terminal UI for Terraplate Synopsis \u00b6 Enters dev mode which launches a Terminal UI for building and running Terraplate root modules. terraplate dev [flags] Options \u00b6 -h, --help help for dev -j, --jobs int Number of concurrent terraform jobs to run at one time (default 4) Options inherited from parent commands \u00b6 -C, --chdir string Switch to a different working directory before executing the given subcommand. (default \".\") SEE ALSO \u00b6 terraplate - DRY Terraform using Go Templates","title":"terraplate dev"},{"location":"commands/terraplate_dev/#terraplate-dev","text":"Enters dev mode which launches a Terminal UI for Terraplate","title":"terraplate dev"},{"location":"commands/terraplate_dev/#synopsis","text":"Enters dev mode which launches a Terminal UI for building and running Terraplate root modules. terraplate dev [flags]","title":"Synopsis"},{"location":"commands/terraplate_dev/#options","text":"-h, --help help for dev -j, --jobs int Number of concurrent terraform jobs to run at one time (default 4)","title":"Options"},{"location":"commands/terraplate_dev/#options-inherited-from-parent-commands","text":"-C, --chdir string Switch to a different working directory before executing the given subcommand. (default \".\")","title":"Options inherited from parent commands"},{"location":"commands/terraplate_dev/#see-also","text":"terraplate - DRY Terraform using Go Templates","title":"SEE ALSO"},{"location":"commands/terraplate_drift/","text":"terraplate drift \u00b6 Detect drift in your infrastructure (experimental feature) Synopsis \u00b6 Detect drift in your infrastructure and send Slack notifications terraplate drift [flags] Options \u00b6 -h, --help help for drift -j, --jobs int Number of concurrent terraform jobs to run at one time (default 4) --notify string Notification type (only slack supported) --notify-on string When to send a notification (possible values are \"all\" and \"drift\") --repo-branch string Branch of the repository to show in notifications --repo-name string Name of the repository to show in notifications --results-url string Provide a custom URL that will be shown in the notification (such as a link to your CI log for easy access) --slack-channel string Slack channel where to send the notification (required if notify=slack) Options inherited from parent commands \u00b6 -C, --chdir string Switch to a different working directory before executing the given subcommand. (default \".\") SEE ALSO \u00b6 terraplate - DRY Terraform using Go Templates","title":"terraplate drift"},{"location":"commands/terraplate_drift/#terraplate-drift","text":"Detect drift in your infrastructure (experimental feature)","title":"terraplate drift"},{"location":"commands/terraplate_drift/#synopsis","text":"Detect drift in your infrastructure and send Slack notifications terraplate drift [flags]","title":"Synopsis"},{"location":"commands/terraplate_drift/#options","text":"-h, --help help for drift -j, --jobs int Number of concurrent terraform jobs to run at one time (default 4) --notify string Notification type (only slack supported) --notify-on string When to send a notification (possible values are \"all\" and \"drift\") --repo-branch string Branch of the repository to show in notifications --repo-name string Name of the repository to show in notifications --results-url string Provide a custom URL that will be shown in the notification (such as a link to your CI log for easy access) --slack-channel string Slack channel where to send the notification (required if notify=slack)","title":"Options"},{"location":"commands/terraplate_drift/#options-inherited-from-parent-commands","text":"-C, --chdir string Switch to a different working directory before executing the given subcommand. (default \".\")","title":"Options inherited from parent commands"},{"location":"commands/terraplate_drift/#see-also","text":"terraplate - DRY Terraform using Go Templates","title":"SEE ALSO"},{"location":"commands/terraplate_init/","text":"terraplate init \u00b6 Runs terraform init on all subdirectories Synopsis \u00b6 Runs terraform init on all subdirectories. terraplate init [flags] Options \u00b6 -h, --help help for init -j, --jobs int Number of concurrent terraform jobs to run at one time (default 4) --skip-build Skip build process (default: false) -u, --upgrade Perform upgrade when initializing Options inherited from parent commands \u00b6 -C, --chdir string Switch to a different working directory before executing the given subcommand. (default \".\") SEE ALSO \u00b6 terraplate - DRY Terraform using Go Templates","title":"terraplate init"},{"location":"commands/terraplate_init/#terraplate-init","text":"Runs terraform init on all subdirectories","title":"terraplate init"},{"location":"commands/terraplate_init/#synopsis","text":"Runs terraform init on all subdirectories. terraplate init [flags]","title":"Synopsis"},{"location":"commands/terraplate_init/#options","text":"-h, --help help for init -j, --jobs int Number of concurrent terraform jobs to run at one time (default 4) --skip-build Skip build process (default: false) -u, --upgrade Perform upgrade when initializing","title":"Options"},{"location":"commands/terraplate_init/#options-inherited-from-parent-commands","text":"-C, --chdir string Switch to a different working directory before executing the given subcommand. (default \".\")","title":"Options inherited from parent commands"},{"location":"commands/terraplate_init/#see-also","text":"terraplate - DRY Terraform using Go Templates","title":"SEE ALSO"},{"location":"commands/terraplate_parse/","text":"terraplate parse \u00b6 Parse the terraplate files and print a summary Synopsis \u00b6 Parse the terraplate files and print a summary. This is useful if you want to check the configuration before running the build command, for example. terraplate parse [flags] Options \u00b6 -h, --help help for parse Options inherited from parent commands \u00b6 -C, --chdir string Switch to a different working directory before executing the given subcommand. (default \".\") SEE ALSO \u00b6 terraplate - DRY Terraform using Go Templates","title":"terraplate parse"},{"location":"commands/terraplate_parse/#terraplate-parse","text":"Parse the terraplate files and print a summary","title":"terraplate parse"},{"location":"commands/terraplate_parse/#synopsis","text":"Parse the terraplate files and print a summary. This is useful if you want to check the configuration before running the build command, for example. terraplate parse [flags]","title":"Synopsis"},{"location":"commands/terraplate_parse/#options","text":"-h, --help help for parse","title":"Options"},{"location":"commands/terraplate_parse/#options-inherited-from-parent-commands","text":"-C, --chdir string Switch to a different working directory before executing the given subcommand. (default \".\")","title":"Options inherited from parent commands"},{"location":"commands/terraplate_parse/#see-also","text":"terraplate - DRY Terraform using Go Templates","title":"SEE ALSO"},{"location":"commands/terraplate_plan/","text":"terraplate plan \u00b6 Runs terraform plan on all subdirectories Synopsis \u00b6 Runs terraform plan on all subdirectories. terraplate plan [flags] Options \u00b6 --dev Start dev mode after plan finishes -h, --help help for plan --init Run terraform init also -j, --jobs int Number of concurrent terraform jobs to run at one time (default 4) --output-level string Level of output to show (all or drift) (default \"all\") --skip-build Skip build process (default: false) Options inherited from parent commands \u00b6 -C, --chdir string Switch to a different working directory before executing the given subcommand. (default \".\") SEE ALSO \u00b6 terraplate - DRY Terraform using Go Templates","title":"terraplate plan"},{"location":"commands/terraplate_plan/#terraplate-plan","text":"Runs terraform plan on all subdirectories","title":"terraplate plan"},{"location":"commands/terraplate_plan/#synopsis","text":"Runs terraform plan on all subdirectories. terraplate plan [flags]","title":"Synopsis"},{"location":"commands/terraplate_plan/#options","text":"--dev Start dev mode after plan finishes -h, --help help for plan --init Run terraform init also -j, --jobs int Number of concurrent terraform jobs to run at one time (default 4) --output-level string Level of output to show (all or drift) (default \"all\") --skip-build Skip build process (default: false)","title":"Options"},{"location":"commands/terraplate_plan/#options-inherited-from-parent-commands","text":"-C, --chdir string Switch to a different working directory before executing the given subcommand. (default \".\")","title":"Options inherited from parent commands"},{"location":"commands/terraplate_plan/#see-also","text":"terraplate - DRY Terraform using Go Templates","title":"SEE ALSO"},{"location":"commands/terraplate_show/","text":"terraplate show \u00b6 Runs terraform show on all subdirectories Synopsis \u00b6 Runs terraform show on all subdirectories. terraplate show [flags] Options \u00b6 -h, --help help for show -j, --jobs int Number of concurrent terraform jobs to run at one time (default 4) --output-level string Level of output to show (all or drift) (default \"all\") --show-progress Whether to show Terraform run progress (default true) Options inherited from parent commands \u00b6 -C, --chdir string Switch to a different working directory before executing the given subcommand. (default \".\") SEE ALSO \u00b6 terraplate - DRY Terraform using Go Templates","title":"terraplate show"},{"location":"commands/terraplate_show/#terraplate-show","text":"Runs terraform show on all subdirectories","title":"terraplate show"},{"location":"commands/terraplate_show/#synopsis","text":"Runs terraform show on all subdirectories. terraplate show [flags]","title":"Synopsis"},{"location":"commands/terraplate_show/#options","text":"-h, --help help for show -j, --jobs int Number of concurrent terraform jobs to run at one time (default 4) --output-level string Level of output to show (all or drift) (default \"all\") --show-progress Whether to show Terraform run progress (default true)","title":"Options"},{"location":"commands/terraplate_show/#options-inherited-from-parent-commands","text":"-C, --chdir string Switch to a different working directory before executing the given subcommand. (default \".\")","title":"Options inherited from parent commands"},{"location":"commands/terraplate_show/#see-also","text":"terraplate - DRY Terraform using Go Templates","title":"SEE ALSO"},{"location":"commands/terraplate_version/","text":"terraplate version \u00b6 Show the Terraplate version terraplate version [flags] Options \u00b6 -h, --help help for version Options inherited from parent commands \u00b6 -C, --chdir string Switch to a different working directory before executing the given subcommand. (default \".\") SEE ALSO \u00b6 terraplate - DRY Terraform using Go Templates","title":"terraplate version"},{"location":"commands/terraplate_version/#terraplate-version","text":"Show the Terraplate version terraplate version [flags]","title":"terraplate version"},{"location":"commands/terraplate_version/#options","text":"-h, --help help for version","title":"Options"},{"location":"commands/terraplate_version/#options-inherited-from-parent-commands","text":"-C, --chdir string Switch to a different working directory before executing the given subcommand. (default \".\")","title":"Options inherited from parent commands"},{"location":"commands/terraplate_version/#see-also","text":"terraplate - DRY Terraform using Go Templates","title":"SEE ALSO"},{"location":"faq/terraplate-vs-terragrunt/","text":"Terragrunt is an amazing tool, that shaped a lot of how Terraform is used today (including Terraplate). However, there are things about Terragrunt that motivated us to write Terraplate, and those have been summarised below. This is in no way to say that Terraplate is better than Terragrunt, but we do feel it is simpler. Native Terraform Syntax \u00b6 Terragrunt does not produce native Terraform code that can be read or version controlled. Of course in the end, Terragrunt generates native Terraform code which is invoked using the Terraform CLI, but this happens at runtime and is managed by Terragrunt. This means: You are dependent on Terragrunt to run Terraform This rules out tools like Terraform Cloud There are subtle differences in syntax between using Terraform features, like modules, which as a concept existed in Terragrunt before they existed in Terraform Calling none or multiple modules \u00b6 Terragrunt is designed to call exactly one Terraform module from each Root Module. Sometimes you don't want to call a Terraform module, or might want to call multiple Terraform modules from the same Root Module. With Terraplate, you can use the templating engine to create things like the backend and providers, and then write a plain .tf file yourself which can do whatever you want it to. Keep it DRY, only \u00b6 Terraplate can be used for just it's templating engine. That way, you can keep your Terraform code DRY whilst not changing the way you invoke Terraform (be it via CI, Terraform Cloud, SpaceLift, env0, etc). Less boilerplate \u00b6 Terraplate has inheritance built in without being explicit (e.g. functions like find_in_parent_folders() don't need to be used). Whilst this is very minor, it does reduce the amount of boilerplate needed in your terraplate.hcl configurations. In fact, some terraplate.hcl files can be completely empty, because they inherit everything from parent terraplate.hcl files. Extra comments \u00b6 There's a lot of things you can do with Terragrunt that you cannot do with Terraplate. Like mentioned, we are Terragrunt fans and have been trying to find a happy place using just Terraform, and that's why Terraplate was created. If you start with Terraplate and find it's not for you; that's ok, there's no lock-in as all the files are just vanilla Terraform. If you are a Terragrunt user and find useful things missing, please raise an issue or discussion :)","title":"Terraplate vs Terragrunt"},{"location":"faq/terraplate-vs-terragrunt/#native-terraform-syntax","text":"Terragrunt does not produce native Terraform code that can be read or version controlled. Of course in the end, Terragrunt generates native Terraform code which is invoked using the Terraform CLI, but this happens at runtime and is managed by Terragrunt. This means: You are dependent on Terragrunt to run Terraform This rules out tools like Terraform Cloud There are subtle differences in syntax between using Terraform features, like modules, which as a concept existed in Terragrunt before they existed in Terraform","title":"Native Terraform Syntax"},{"location":"faq/terraplate-vs-terragrunt/#calling-none-or-multiple-modules","text":"Terragrunt is designed to call exactly one Terraform module from each Root Module. Sometimes you don't want to call a Terraform module, or might want to call multiple Terraform modules from the same Root Module. With Terraplate, you can use the templating engine to create things like the backend and providers, and then write a plain .tf file yourself which can do whatever you want it to.","title":"Calling none or multiple modules"},{"location":"faq/terraplate-vs-terragrunt/#keep-it-dry-only","text":"Terraplate can be used for just it's templating engine. That way, you can keep your Terraform code DRY whilst not changing the way you invoke Terraform (be it via CI, Terraform Cloud, SpaceLift, env0, etc).","title":"Keep it DRY, only"},{"location":"faq/terraplate-vs-terragrunt/#less-boilerplate","text":"Terraplate has inheritance built in without being explicit (e.g. functions like find_in_parent_folders() don't need to be used). Whilst this is very minor, it does reduce the amount of boilerplate needed in your terraplate.hcl configurations. In fact, some terraplate.hcl files can be completely empty, because they inherit everything from parent terraplate.hcl files.","title":"Less boilerplate"},{"location":"faq/terraplate-vs-terragrunt/#extra-comments","text":"There's a lot of things you can do with Terragrunt that you cannot do with Terraplate. Like mentioned, we are Terragrunt fans and have been trying to find a happy place using just Terraform, and that's why Terraplate was created. If you start with Terraplate and find it's not for you; that's ok, there's no lock-in as all the files are just vanilla Terraform. If you are a Terragrunt user and find useful things missing, please raise an issue or discussion :)","title":"Extra comments"},{"location":"faq/terraplate-vs-tf-workspaces/","text":"Terraform Workspaces \u00b6 Terraform Workspaces are a feature of Terraform that enable you to use different backends (state storage) for a single root module (i.e. directory). This means you can have exactly the same Terraform code, and substitue the variables to manage different environments. Thus, workspaces help to keep Terraform DRY but only for a single Root Module with Terraform variable substitution. Terraplate, on the other hand, allows you to template any Terraform code (such as backend, providers, resources, module invocations) for any Root Module that has a Terrafile. Workspaces and Terraplate solve similar issues, but should be not be considered directly as alternatives. In fact, you can use Workspaces and Terraplate together. When to use workspaces \u00b6 Terraform's own documentation do not recommend workspaces in certain cases: Workspaces alone are not a suitable tool for system decomposition, because each subsystem should have its own separate configuration and backend, and will thus have its own distinct set of workspaces.","title":"Terraplate vs Terraform Workspaces"},{"location":"faq/terraplate-vs-tf-workspaces/#terraform-workspaces","text":"Terraform Workspaces are a feature of Terraform that enable you to use different backends (state storage) for a single root module (i.e. directory). This means you can have exactly the same Terraform code, and substitue the variables to manage different environments. Thus, workspaces help to keep Terraform DRY but only for a single Root Module with Terraform variable substitution. Terraplate, on the other hand, allows you to template any Terraform code (such as backend, providers, resources, module invocations) for any Root Module that has a Terrafile. Workspaces and Terraplate solve similar issues, but should be not be considered directly as alternatives. In fact, you can use Workspaces and Terraplate together.","title":"Terraform Workspaces"},{"location":"faq/terraplate-vs-tf-workspaces/#when-to-use-workspaces","text":"Terraform's own documentation do not recommend workspaces in certain cases: Workspaces alone are not a suitable tool for system decomposition, because each subsystem should have its own separate configuration and backend, and will thus have its own distinct set of workspaces.","title":"When to use workspaces"},{"location":"reference/complete/","text":"examples/complete/terraplate.hcl # Define a template that reads from a file template \"example\" { contents = read_template ( \"example.tmpl\" ) # Override the target where to write the file (default: example.tp.tf) target = \"example_custom.tp.tf\" condition = \"{{ eq .Locals.key \\\"value\\\" }}\" } # Define a template that embeds the content template \"embedded\" { contents = <<- EOL # Content here will be templated EOL } # Define terraform locals that can be used for templating and are written to the # terraplate.tf file locals { key = \"value\" other = { msg = \"can also be an object\" nested = { list = [ \"and an object\", \"with a list\" ] } } } # Define terraform variables that can be used for templating and are written to the # terraplate.tf file variables { key = \"value\" } # Define values that can be used for templating but are *not* written to any # terraform files values { key = \"value\" } # Define an exec block configuring how terraform is executed from terraplate exec { # Whether to skip running terraform. This is useful for disabling some root # modules but wanting to keep them in Git skip = false # Extra args arbitrary strings passed to terraform for each invocation extra_args = [] # Plan controls the behaviour for running terraform plan, and subsequntly # affects some of the terraform apply commands plan { # Whether to enable/disable inputs (terraform's -input option) input = false # Whether to hold a state lock (terraform's -lock option) lock = true # Name of terraform plan out file that can be used as input for terraform # apply (terraform's -out option) out = \"tfplan\" # Whether to skip producing an output. Default is false (i.e. use an out file) skip_out = false } } # Define a terraform block for providing things like required_providers which are # built into the terrafile.tf output file terraform { # Required providers are output to the terraplate.tf file required_providers { local = { source = \"hashicorp/local\" version = \"2.1.0\" } } required_version = \">= 1.1.0\" }","title":"Complete Terrafile"},{"location":"reference/terrafile/","text":"Here are the different configurations that are supported in a Terrafile. Locals \u00b6 locals block defines a map of Terraform locals that will be written to the terraplate.tf file. Use the locals block for controlling values in your root modules, e.g. environment , region , project . Use locals when you want to reference these values in your Terraform code. Prefer locals over variables unless you want to override something at runtime; in that case variables are your friend. Example: terraplate.hcl locals { environment = \"dev\" } Output: terraplate.tf locals { environment = \"dev\" } Use this in your Terraform files as a normal Terraform variable, e.g. ${local.environment} Variables \u00b6 variables block defines a map of Terraform variables that will be written to the terraplate.tf file with default values. Prefer locals over variables if you will not be overriding inputs at runtime. Example: terraplate.hcl variables { environment = \"dev\" } Output: terraplate.tf variable \"environment\" { default = \"dev\" } Use this in your Terraform files as a normal Terraform variable, e.g. ${var.environment} Values \u00b6 values block defines a map of values that are passed to the Go template executor when running the Terraplate build process. Use this instead of locals or variables if you do not want to expose values as Terraform variables but only want to use them during the build process. A prime example of this is configuring the Terraform backend because variables cannot be used for this. Example: terraplate.hcl values { some_value = \"hello!\" } templates/some_value.tp.tf.hcl locals { some_value = \"{{ .Values.some_value }}\" } Output: some_value.tp.tf locals { some_value = \"hello!\" } Templates \u00b6 template block defines a template that will be built to all child root modules (as Terrafiles inherit from their parents). Templates can also define non-Terraform files in case you want to just do some general-purpose templating, such as creating Makefiles or something spicy. But we're just gonna do plain ol' DRY Terraform. Example: backend.tmpl terraform { backend \"s3\" { bucket = \"bucket-name\" key = \"{{ .RelativeDir }}/terraform.tfstate\" region = \"{{ .Locals.aws_region }}\" encrypt = true } } terraplate.hcl # Define a template to be built, reading the template we have defined. # All child terrafiles will inherit and build this template. template \"backend\" { # read_template is a custom function that parses up the directory tree, # looking for a matching template file contents = read_template ( \"backend.tmpl\" ) # target is optional, and defaults to the template name with a \"tp.tf\" suffix # (e.g. \"backend.tp.tf\" for this template) target = \"backend.tp.tf\" } # Templates can also embed the contents directly template \"embedded\" { contents = <<- EOL # Template this EOL } # Templates can also have conditional logic when to build them, which makes them # very powerful template \"provider_aws_dev\" { contents = <<- EOL provider \"aws\" { alias = \"dev\" region = \"eu-west-1\" access_key = \"my-access-key\" secret_key = \"my-secret-key\" } EOL # Specify a condition, which if it evaluates to true, will build the template # in that root module condition = \"{{ eq .Locals.environment \\\"dev\\\" }}\" } Required Providers \u00b6 required_providers defines the required providers for a Terraform root module. It is built into a terraform {} block inside a terraplate.tf file. Example: terraplate.hcl terraform { required_providers { local = { source = \"hashicorp/local\" version = \"2.1.0\" } } } Output: terraplate.tf terraform { # ... required_providers { local = { source = \"hashicorp/local\" version = \"2.1.0\" } } } Terraform Docs: https://www.terraform.io/language/providers/requirements#requiring-providers Required Version \u00b6 required_version accepts a string. It is built into a terraform {} block inside a terraplate.tf file. Example: terraplate.hcl terraform { required_version = \">= 1.1.0\" } Output: terraplate.tf terraform { required_version = \">= 1.1.0\" # ... } Terraform Docs: https://www.terraform.io/language/settings#specifying-a-required-terraform-version","title":"Terrafile"},{"location":"reference/terrafile/#locals","text":"locals block defines a map of Terraform locals that will be written to the terraplate.tf file. Use the locals block for controlling values in your root modules, e.g. environment , region , project . Use locals when you want to reference these values in your Terraform code. Prefer locals over variables unless you want to override something at runtime; in that case variables are your friend. Example: terraplate.hcl locals { environment = \"dev\" } Output: terraplate.tf locals { environment = \"dev\" } Use this in your Terraform files as a normal Terraform variable, e.g. ${local.environment}","title":"Locals"},{"location":"reference/terrafile/#variables","text":"variables block defines a map of Terraform variables that will be written to the terraplate.tf file with default values. Prefer locals over variables if you will not be overriding inputs at runtime. Example: terraplate.hcl variables { environment = \"dev\" } Output: terraplate.tf variable \"environment\" { default = \"dev\" } Use this in your Terraform files as a normal Terraform variable, e.g. ${var.environment}","title":"Variables"},{"location":"reference/terrafile/#values","text":"values block defines a map of values that are passed to the Go template executor when running the Terraplate build process. Use this instead of locals or variables if you do not want to expose values as Terraform variables but only want to use them during the build process. A prime example of this is configuring the Terraform backend because variables cannot be used for this. Example: terraplate.hcl values { some_value = \"hello!\" } templates/some_value.tp.tf.hcl locals { some_value = \"{{ .Values.some_value }}\" } Output: some_value.tp.tf locals { some_value = \"hello!\" }","title":"Values"},{"location":"reference/terrafile/#templates","text":"template block defines a template that will be built to all child root modules (as Terrafiles inherit from their parents). Templates can also define non-Terraform files in case you want to just do some general-purpose templating, such as creating Makefiles or something spicy. But we're just gonna do plain ol' DRY Terraform. Example: backend.tmpl terraform { backend \"s3\" { bucket = \"bucket-name\" key = \"{{ .RelativeDir }}/terraform.tfstate\" region = \"{{ .Locals.aws_region }}\" encrypt = true } } terraplate.hcl # Define a template to be built, reading the template we have defined. # All child terrafiles will inherit and build this template. template \"backend\" { # read_template is a custom function that parses up the directory tree, # looking for a matching template file contents = read_template ( \"backend.tmpl\" ) # target is optional, and defaults to the template name with a \"tp.tf\" suffix # (e.g. \"backend.tp.tf\" for this template) target = \"backend.tp.tf\" } # Templates can also embed the contents directly template \"embedded\" { contents = <<- EOL # Template this EOL } # Templates can also have conditional logic when to build them, which makes them # very powerful template \"provider_aws_dev\" { contents = <<- EOL provider \"aws\" { alias = \"dev\" region = \"eu-west-1\" access_key = \"my-access-key\" secret_key = \"my-secret-key\" } EOL # Specify a condition, which if it evaluates to true, will build the template # in that root module condition = \"{{ eq .Locals.environment \\\"dev\\\" }}\" }","title":"Templates"},{"location":"reference/terrafile/#required-providers","text":"required_providers defines the required providers for a Terraform root module. It is built into a terraform {} block inside a terraplate.tf file. Example: terraplate.hcl terraform { required_providers { local = { source = \"hashicorp/local\" version = \"2.1.0\" } } } Output: terraplate.tf terraform { # ... required_providers { local = { source = \"hashicorp/local\" version = \"2.1.0\" } } } Terraform Docs: https://www.terraform.io/language/providers/requirements#requiring-providers","title":"Required Providers"},{"location":"reference/terrafile/#required-version","text":"required_version accepts a string. It is built into a terraform {} block inside a terraplate.tf file. Example: terraplate.hcl terraform { required_version = \">= 1.1.0\" } Output: terraplate.tf terraform { required_version = \">= 1.1.0\" # ... } Terraform Docs: https://www.terraform.io/language/settings#specifying-a-required-terraform-version","title":"Required Version"},{"location":"tutorials/dev-mode/","text":"This tutorial gives a very quick overview of Terraplate's dev mode. Dev mode \u00b6 Terraplate's dev mode launches a Terminal UI for working with multiple root modules and executing Terraform via Terraplate. Entering dev mode \u00b6 You can either run terraplate dev or terraplate plan --dev to start dev mode. With the dev subcommand the TUI starts up immediately. With the plan --dev subcommand, the plan finishes before starting the TUI. Command mode \u00b6 Once in dev mode, you can press : to enter command mode, and you can do the following: b for build i for init u for init -upgrade p for plan a for apply A for all (run over all visible root modules) Finally press enter to run the commands over the root module(s). For example the following keypresses will build, init (with upgrade) and plan all visible root modules: :bupA<enter> . Help \u00b6 Check the help at the bottom of the TUI. You can press ? to get the extended help.","title":"Dev mode (TUI)"},{"location":"tutorials/dev-mode/#dev-mode","text":"Terraplate's dev mode launches a Terminal UI for working with multiple root modules and executing Terraform via Terraplate.","title":"Dev mode"},{"location":"tutorials/dev-mode/#entering-dev-mode","text":"You can either run terraplate dev or terraplate plan --dev to start dev mode. With the dev subcommand the TUI starts up immediately. With the plan --dev subcommand, the plan finishes before starting the TUI.","title":"Entering dev mode"},{"location":"tutorials/dev-mode/#command-mode","text":"Once in dev mode, you can press : to enter command mode, and you can do the following: b for build i for init u for init -upgrade p for plan a for apply A for all (run over all visible root modules) Finally press enter to run the commands over the root module(s). For example the following keypresses will build, init (with upgrade) and plan all visible root modules: :bupA<enter> .","title":"Command mode"},{"location":"tutorials/dev-mode/#help","text":"Check the help at the bottom of the TUI. You can press ? to get the extended help.","title":"Help"},{"location":"tutorials/drift-slack-notifications/","text":"Drift detection is currently an experimental feature Terraplate uses the terraform show command to output a plan as JSON, which it then parses to detect drift. The terraplate drift commands allows you to run Terraform over all your Root Modules that have a terraplate.hcl file (\"Terrafile\"), and send notifications based on the result. Terraplate only provides the capability to do one-off drift detections, so it is up to you to make this run at a schedule (e.g. via CI, or Kubernetes CronJob). Slack notification example # Set the Slack API token which is used to authenticate with export SLACK_API_TOKEN = <slack-token> # Detect drift and send a notification if there was drift (or an error) terraplate drift --notify = slack --slack-channel = <slack-channel> --notify-on drift The --notify flag says which notification service to use, the --slack-channel says which Slack channel to post the notification to, and the --notify-on flag accepts either all (always send a notificaiton) or drift (only send a notification if there's drift detected, or an error occurred). Configuration \u00b6 Slack API Token \u00b6 Getting a Slack API token requires you to create an application. For example, the ArgoCD notes on this are very clear so let's refer to those: https://argocd-notifications.readthedocs.io/en/stable/services/slack/ Set the token via the SLACK_API_TOKEN environment variable. Repository \u00b6 The Slack notification requires details on your repository to send to Slack. There is a simple bit of logic in Terraplate to try and detect the repository name using the origin remote, and the repository branch using HEAD . If this fails, or you want to give something custom, use the --repo-name and --repo-branch flags, or set the TP_REPO_NAME or TP_REPO_BRANCH environment variables. You can also specify a URL to show under the repository information with the --results-url flag, such as a link to your CI logs for easy access. Example \u00b6 No drift detected \u00b6 This is only shown when the --notify-on=all Drift detected \u00b6 Error occurred \u00b6","title":"Drift detection with Slack notifications"},{"location":"tutorials/drift-slack-notifications/#configuration","text":"","title":"Configuration"},{"location":"tutorials/drift-slack-notifications/#slack-api-token","text":"Getting a Slack API token requires you to create an application. For example, the ArgoCD notes on this are very clear so let's refer to those: https://argocd-notifications.readthedocs.io/en/stable/services/slack/ Set the token via the SLACK_API_TOKEN environment variable.","title":"Slack API Token"},{"location":"tutorials/drift-slack-notifications/#repository","text":"The Slack notification requires details on your repository to send to Slack. There is a simple bit of logic in Terraplate to try and detect the repository name using the origin remote, and the repository branch using HEAD . If this fails, or you want to give something custom, use the --repo-name and --repo-branch flags, or set the TP_REPO_NAME or TP_REPO_BRANCH environment variables. You can also specify a URL to show under the repository information with the --results-url flag, such as a link to your CI logs for easy access.","title":"Repository"},{"location":"tutorials/drift-slack-notifications/#example","text":"","title":"Example"},{"location":"tutorials/drift-slack-notifications/#no-drift-detected","text":"This is only shown when the --notify-on=all","title":"No drift detected"},{"location":"tutorials/drift-slack-notifications/#drift-detected","text":"","title":"Drift detected"},{"location":"tutorials/drift-slack-notifications/#error-occurred","text":"","title":"Error occurred"},{"location":"tutorials/multiple-root-modules/","text":"This tutorial is a light introduction to Terraplate where we take a single Terraform Root Module and split it into multiple root modules, whilst keeping things DRY. Example Root Module \u00b6 Let's setup a basic Terraform root module where we use the local provider so you don't need to worry about cloud providers. # Check out the terraplate codebase containing the tutorials git clone https://github.com/verifa/terraplate.git # Go to the tutorial cd terraplate/tutorials/multiple-root-modules Resources (and provider) \u00b6 In there we should have a Terraform file with something like the following, which will create two files: one for dev and one for prod. Ignore that this is stupidly simple and imagine instead you are creating VPCs, VMs, Kubernetes clusters, ... whatever you normally do! main.tf provider \"local\" { # No configuration required } # Create our dev environment resource \"local_file\" \"dev\" { content = \"env = dev\" filename = \"${path.module}/dev.txt\" } # Create our prod environment resource \"local_file\" \"prod\" { content = \"env = prod\" filename = \"${path.module}/prod.txt\" } Backend \u00b6 The backend.tf file defines where the Terraform state should be stored. This config replicates the default backend which is to store the state in a local file called terraform.tfstate . backend.tf terraform { backend \"local\" { path = \"terraform.tfstate\" } } Versions \u00b6 The versions.tf file contains the required providers and the Terraform CLI version. versions.tf terraform { required_version = \">= 1.0\" required_providers { local = { source = \"hashicorp/local\" version = \"2.1.0\" } } } Apply the configuration \u00b6 Now we will apply the configuration using basic Terraform # Initialize the root module terraform init # Plan the root module terraform plan -out tfplan # Apply based on the plan output terraform apply tfplan # Check output cat prod.txt cat dev.txt Great! This should've worked. And let's imagine that it took a long time to plan, because of all your resources being inside a single Root Module and therefore a single state. Using Terraplate \u00b6 Let's refactor this code and split the two local_file resources up into their own Root Modules and use Terraplate to keep things DRY. Take a look in the tutorials/multiple-root-modules-finished directory for the same codebase that has been Terraplate'd. Terraplate Structure # Move into the finished tutorial cd tutorials/multiple-root-modules-finished # Check the files we have tree . \u251c\u2500\u2500 README.md \u251c\u2500\u2500 local \u2502 \u251c\u2500\u2500 dev \u2502 \u2502 \u251c\u2500\u2500 main.tf \u2502 \u2502 \u2514\u2500\u2500 terraplate.hcl \u2502 \u251c\u2500\u2500 prod \u2502 \u2502 \u251c\u2500\u2500 main.tf \u2502 \u2502 \u2514\u2500\u2500 terraplate.hcl \u2502 \u2514\u2500\u2500 terraplate.hcl \u251c\u2500\u2500 templates \u2502 \u2514\u2500\u2500 provider_local.tmpl \u2514\u2500\u2500 terraplate.hcl Resource files \u00b6 Let's inspect the main.tf files in the local/dev and local/prod environments. Note that these are identical and manually maintained (NOT currently generated by Terraplate). local/dev/main.tf resource \"local_file\" \"this\" { content = \"env = ${local.environment}\" filename = \"${path.module}/${local.environment}.txt\" } Templates \u00b6 Currently we have two templates in the templates/ directory. templates directory is a convention The templates directory is not required but it's a convention to keep the template files organized. Putting files in a templates does not mean or do anything: you still have to declare your templates using a templates block inside your Terrafiles. They will be processed by the Go templating engine so we could set values we want based on the Root Module where it should be templated. But for these simple files we don't need it. templates/backend_local.tmpl terraform { backend \"local\" { path = \"terraform.tfstate\" } } templates/provider_local.tmpl provider \"local\" { # No configuration required } We need to declare these templates in our Terrafiles. The backend we want to use in every root module so we will declare it in the root Terrafile terraplate.hcl . The local provider we only want to use in the Terrafiles under the local/ directory, so we place it in the local/terraplate.hcl Terrafile and all the child directories will inherit this template. That takes care of the backend and providers. Versions \u00b6 Defining the required Terraform version and required_providers everywhere is tiresome to do and maintain. With Terraplate we keep the required versions at each level in the directory structure where we need them, and the child directories inherit those. At the root level, terraplate.hcl , we define the Terraform CLI version. At the local/terraplate.hcl directory level we declare the local provider. Terrafiles \u00b6 terraplate.hcl template \"backend\" { contents = read_template ( \"backend_local.tmpl\" ) } terraform { required_version = \">= 1.0\" } local/terraplate.hcl template \"provider_local\" { contents = read_template ( \"provider_local.tmpl\" ) } terraform { required_providers { local = { source = \"hashicorp/local\" version = \"2.1.0\" } } } local/dev/terraplate.hcl locals { environment = \"dev\" } local/prod/terraplate.hcl locals { environment = \"prod\" } Apply using Terraplate \u00b6 Apply with Terraplate # The parse command gives us a summary of the Root Modules ( useful for debugging ) terraplate parse # Let ' s build the templates terraplate build # Then we can plan ( and init in the same run ) terraplate plan --init # Finally apply the plans terraplate plan Want to get even DRYer? \u00b6 The main.tf file is currently the same for the dev and prod environments. We could define a template for this, let's say under the local/templates directory. local/templates/file.tmpl resource \"local_file\" \"dev\" { # We can use Go templates to build the value right in the file if we want!! content = \"env = {{ .Locals.environment }}\" filename = \"${path.module}/${local.environment}.txt\" } local/terraplate.hcl template \"file\" { contents = read_template ( \"file.tmpl\" ) } # Remove the files we are about to make DRY rm local/dev/main.tf local/prod/main.tf # Re-build to generate our new ` file.tp.tf ` files terraplate build # Plan and see that there should be no changes... terraplate plan Summary \u00b6 We had a single root module with a single state that we separated into two root modules and therefore two separate states . We can now create many more root modules and the version, providers and backend are inherited and templated for us by Terraplate. Thus, the steps for creating a new root module, such as a staging would be as follows: Creating a new Root Module mkdir local/staging touch local/staging/terraplate.hcl And something like the following in your terraplate.hcl file local/staging/terraplate.hcl locals { environment = \"staging\" } Then just add your .tf files, or add some more templates, and away we go!","title":"Multiple root modules"},{"location":"tutorials/multiple-root-modules/#example-root-module","text":"Let's setup a basic Terraform root module where we use the local provider so you don't need to worry about cloud providers. # Check out the terraplate codebase containing the tutorials git clone https://github.com/verifa/terraplate.git # Go to the tutorial cd terraplate/tutorials/multiple-root-modules","title":"Example Root Module"},{"location":"tutorials/multiple-root-modules/#resources-and-provider","text":"In there we should have a Terraform file with something like the following, which will create two files: one for dev and one for prod. Ignore that this is stupidly simple and imagine instead you are creating VPCs, VMs, Kubernetes clusters, ... whatever you normally do! main.tf provider \"local\" { # No configuration required } # Create our dev environment resource \"local_file\" \"dev\" { content = \"env = dev\" filename = \"${path.module}/dev.txt\" } # Create our prod environment resource \"local_file\" \"prod\" { content = \"env = prod\" filename = \"${path.module}/prod.txt\" }","title":"Resources (and provider)"},{"location":"tutorials/multiple-root-modules/#backend","text":"The backend.tf file defines where the Terraform state should be stored. This config replicates the default backend which is to store the state in a local file called terraform.tfstate . backend.tf terraform { backend \"local\" { path = \"terraform.tfstate\" } }","title":"Backend"},{"location":"tutorials/multiple-root-modules/#versions","text":"The versions.tf file contains the required providers and the Terraform CLI version. versions.tf terraform { required_version = \">= 1.0\" required_providers { local = { source = \"hashicorp/local\" version = \"2.1.0\" } } }","title":"Versions"},{"location":"tutorials/multiple-root-modules/#apply-the-configuration","text":"Now we will apply the configuration using basic Terraform # Initialize the root module terraform init # Plan the root module terraform plan -out tfplan # Apply based on the plan output terraform apply tfplan # Check output cat prod.txt cat dev.txt Great! This should've worked. And let's imagine that it took a long time to plan, because of all your resources being inside a single Root Module and therefore a single state.","title":"Apply the configuration"},{"location":"tutorials/multiple-root-modules/#using-terraplate","text":"Let's refactor this code and split the two local_file resources up into their own Root Modules and use Terraplate to keep things DRY. Take a look in the tutorials/multiple-root-modules-finished directory for the same codebase that has been Terraplate'd. Terraplate Structure # Move into the finished tutorial cd tutorials/multiple-root-modules-finished # Check the files we have tree . \u251c\u2500\u2500 README.md \u251c\u2500\u2500 local \u2502 \u251c\u2500\u2500 dev \u2502 \u2502 \u251c\u2500\u2500 main.tf \u2502 \u2502 \u2514\u2500\u2500 terraplate.hcl \u2502 \u251c\u2500\u2500 prod \u2502 \u2502 \u251c\u2500\u2500 main.tf \u2502 \u2502 \u2514\u2500\u2500 terraplate.hcl \u2502 \u2514\u2500\u2500 terraplate.hcl \u251c\u2500\u2500 templates \u2502 \u2514\u2500\u2500 provider_local.tmpl \u2514\u2500\u2500 terraplate.hcl","title":"Using Terraplate"},{"location":"tutorials/multiple-root-modules/#resource-files","text":"Let's inspect the main.tf files in the local/dev and local/prod environments. Note that these are identical and manually maintained (NOT currently generated by Terraplate). local/dev/main.tf resource \"local_file\" \"this\" { content = \"env = ${local.environment}\" filename = \"${path.module}/${local.environment}.txt\" }","title":"Resource files"},{"location":"tutorials/multiple-root-modules/#templates","text":"Currently we have two templates in the templates/ directory. templates directory is a convention The templates directory is not required but it's a convention to keep the template files organized. Putting files in a templates does not mean or do anything: you still have to declare your templates using a templates block inside your Terrafiles. They will be processed by the Go templating engine so we could set values we want based on the Root Module where it should be templated. But for these simple files we don't need it. templates/backend_local.tmpl terraform { backend \"local\" { path = \"terraform.tfstate\" } } templates/provider_local.tmpl provider \"local\" { # No configuration required } We need to declare these templates in our Terrafiles. The backend we want to use in every root module so we will declare it in the root Terrafile terraplate.hcl . The local provider we only want to use in the Terrafiles under the local/ directory, so we place it in the local/terraplate.hcl Terrafile and all the child directories will inherit this template. That takes care of the backend and providers.","title":"Templates"},{"location":"tutorials/multiple-root-modules/#versions_1","text":"Defining the required Terraform version and required_providers everywhere is tiresome to do and maintain. With Terraplate we keep the required versions at each level in the directory structure where we need them, and the child directories inherit those. At the root level, terraplate.hcl , we define the Terraform CLI version. At the local/terraplate.hcl directory level we declare the local provider.","title":"Versions"},{"location":"tutorials/multiple-root-modules/#terrafiles","text":"terraplate.hcl template \"backend\" { contents = read_template ( \"backend_local.tmpl\" ) } terraform { required_version = \">= 1.0\" } local/terraplate.hcl template \"provider_local\" { contents = read_template ( \"provider_local.tmpl\" ) } terraform { required_providers { local = { source = \"hashicorp/local\" version = \"2.1.0\" } } } local/dev/terraplate.hcl locals { environment = \"dev\" } local/prod/terraplate.hcl locals { environment = \"prod\" }","title":"Terrafiles"},{"location":"tutorials/multiple-root-modules/#apply-using-terraplate","text":"Apply with Terraplate # The parse command gives us a summary of the Root Modules ( useful for debugging ) terraplate parse # Let ' s build the templates terraplate build # Then we can plan ( and init in the same run ) terraplate plan --init # Finally apply the plans terraplate plan","title":"Apply using Terraplate"},{"location":"tutorials/multiple-root-modules/#want-to-get-even-dryer","text":"The main.tf file is currently the same for the dev and prod environments. We could define a template for this, let's say under the local/templates directory. local/templates/file.tmpl resource \"local_file\" \"dev\" { # We can use Go templates to build the value right in the file if we want!! content = \"env = {{ .Locals.environment }}\" filename = \"${path.module}/${local.environment}.txt\" } local/terraplate.hcl template \"file\" { contents = read_template ( \"file.tmpl\" ) } # Remove the files we are about to make DRY rm local/dev/main.tf local/prod/main.tf # Re-build to generate our new ` file.tp.tf ` files terraplate build # Plan and see that there should be no changes... terraplate plan","title":"Want to get even DRYer?"},{"location":"tutorials/multiple-root-modules/#summary","text":"We had a single root module with a single state that we separated into two root modules and therefore two separate states . We can now create many more root modules and the version, providers and backend are inherited and templated for us by Terraplate. Thus, the steps for creating a new root module, such as a staging would be as follows: Creating a new Root Module mkdir local/staging touch local/staging/terraplate.hcl And something like the following in your terraplate.hcl file local/staging/terraplate.hcl locals { environment = \"staging\" } Then just add your .tf files, or add some more templates, and away we go!","title":"Summary"}]}